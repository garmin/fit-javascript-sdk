/////////////////////////////////////////////////////////////////////////////////////////////
// Copyright 2025 Garmin International, Inc.
// Licensed under the Flexible and Interoperable Data Transfer (FIT) Protocol License; you
// may not use this file except in compliance with the Flexible and Interoperable Data
// Transfer (FIT) Protocol License.
/////////////////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 21.161.0Release
// Tag = production/release/21.161.0-0-g58854c0
/////////////////////////////////////////////////////////////////////////////////////////////


import FIT from "./fit.js";
import Profile from "./profile.js";

const textEncoder = new TextEncoder();

class MesgDefinition {
    globalMesgNumber;
    localMesgNum;
    fieldDefinitions = [];
    developerFieldDefinitions = [];

    constructor(mesgNum, mesg, { fieldDescriptions = null, } = {}) {
        try {
            if (mesg == null) {
                throw new Error("mesg is missing or null");
            }

            if (mesgNum == null) {
                throw new Error("mesgNum is missing or null");
            }

            const mesgProfile = Profile.messages[mesgNum];

            if (mesgProfile == null) {
                throw new Error(`mesgNum: ${mesgNum} could not be found in the Profile`);
            }

            this.globalMesgNumber = mesgNum;
            this.localMesgNum = 0;

            Object.keys(mesg).forEach((fieldName) => {
                if (mesg[fieldName] == null) {
                    return;
                }

                const fieldProfile = Object.entries(mesgProfile.fields).find(([, fieldProfile,]) => {
                    return fieldProfile.name === fieldName;
                });

                if (fieldProfile == null) {
                    return;
                }

                const baseType = FIT.FieldTypeToBaseType[fieldProfile[1].baseType];
                const baseTypeDef = FIT.BaseTypeDefinitions[baseType];

                this.fieldDefinitions.push({
                    name: fieldName,
                    num: fieldProfile[1].num,
                    size: this.#fieldSize(mesg[fieldName], baseTypeDef),
                    baseType: baseType,
                    type: fieldProfile[1].type,
                    scale: fieldProfile[1].scale,
                    offset: fieldProfile[1].offset,
                });
            });

            Object.keys(mesg.developerFields ?? {})?.sort()?.forEach((key) => {
                const { developerDataIdMesg, fieldDescriptionMesg, } = this.#fieldDescriptionForKey(fieldDescriptions, key);

                const baseTypeDef = FIT.BaseTypeDefinitions[fieldDescriptionMesg.fitBaseTypeId];

                this.developerFieldDefinitions.push({
                    key,
                    baseType: fieldDescriptionMesg.fitBaseTypeId,
                    fieldDefinitionNumber: fieldDescriptionMesg.fieldDefinitionNumber,
                    size: this.#fieldSize(mesg.developerFields[key], baseTypeDef),
                    developerDataIndex: developerDataIdMesg.developerDataIndex,
                });
            });

            if (this.fieldDefinitions.length === 0) {
                throw new Error("No valid fields were found in the message");
            }

            if (this.fieldDefinitions.some((fieldDefinition) => {
                return fieldDefinition.size > FIT.MAX_FIELD_SIZE;
            })) {
                throw new Error(`Some field sizes are greater than ${FIT.MAX_FIELD_SIZE}`, { cause: this.fieldDefinitions, });
            }
        }
        catch (error) {
            throw new Error(
                "Could not construct MesgDefinition from Message", {
                cause: {
                    cause: {
                        message: error.message,
                        cause: error.cause,
                    },
                },
            }
            );
        }
    }

    write(outputStream) {
        // Header
        let headerByte = FIT.MESG_DEFINITION_MASK | (this.localMesgNum & FIT.LOCAL_MESG_NUM_MASK);
        if (this.developerFieldDefinitions.length > 0) {
            headerByte |= FIT.DEV_DATA_MASK;
        }

        outputStream.writeUInt8(headerByte);

        // Reserved Byte
        outputStream.writeUInt8(0x00);

        // Architecture
        outputStream.writeUInt8(FIT.ARCH_LITTLE_ENDIAN);

        // Global Message Number
        outputStream.writeUInt16(this.globalMesgNumber);

        // Field Count
        outputStream.writeUInt8(this.fieldDefinitions.length);

        // Field Definitions
        this.fieldDefinitions.forEach((fieldDefinition) => {
            outputStream.writeUInt8(fieldDefinition.num);
            outputStream.writeUInt8(fieldDefinition.size);
            outputStream.writeUInt8(fieldDefinition.baseType);
        });

        // Developer Field Definitions
        if (this.developerFieldDefinitions.length > 0) {
            outputStream.writeUInt8(this.developerFieldDefinitions.length);

            this.developerFieldDefinitions.forEach((developerFieldDefinition) => {
                outputStream.writeUInt8(developerFieldDefinition.fieldDefinitionNumber);
                outputStream.writeUInt8(developerFieldDefinition.size);
                outputStream.writeUInt8(developerFieldDefinition.developerDataIndex);
            });
        }
    }

    equals(other) {
        if (this.globalMessageNumber !== other.globalMessageNumber
            || this.fieldDefinitions.length !== other.fieldDefinitions.length
            || this.developerFieldDefinitions.length !== other.developerFieldDefinitions.length) {
            return false;
        }

        // Field Definitions
        for (let i = 0; i < this.fieldDefinitions.length; i++) {
            const lhs = this.fieldDefinitions[i];

            if (null == other.fieldDefinitions.find((rhs) => {
                return lhs.num === rhs.num
                    && lhs.size === rhs.size
                    && lhs.baseType === rhs.baseType;
            })) {
                return false;
            }
        }

        // Developer Field Definitions
        for (let i = 0; i < this.developerFieldDefinitions.length; i++) {
            const lhs = this.developerFieldDefinitions[i];

            if (null == other.developerFieldDefinitions.find((rhs) => {
                return lhs.fieldDefinitionNumber === rhs.fieldDefinitionNumber
                    && lhs.size === rhs.size
                    && lhs.developerDataIndex === rhs.developerDataIndex;
            })) {
                return false;
            }
        }

        return true;
    }

    #fieldSize(value, baseTypeDef) {
        const values = Array.isArray(value) ? value : [value,];

        if (baseTypeDef.type === FIT.BaseType.STRING) {
            const size = values.reduce(
                (accumulator, currentValue) => {
                    return accumulator + textEncoder.encode(currentValue).length + 1;
                },
                0
            );

            return size;
        }

        return baseTypeDef.size * values.length;
    };

    /**
     * Look up the field description for the key, and validate the required fields.
     */
    #fieldDescriptionForKey(fieldDescriptions, key) {
        try {
            if (fieldDescriptions == null) {
                throw new Error("no developer data field descriptions provided", {
                    cause: {
                        fieldDescriptions,
                    },
                });
            }

            const { developerDataIdMesg, fieldDescriptionMesg, } = fieldDescriptions?.[key] ?? {};

            if (developerDataIdMesg == null || fieldDescriptionMesg == null) {
                throw new Error(`could not find a developer field description for key ${key}`);
            }

            const errors = [];

            if (fieldDescriptionMesg.fitBaseTypeId == null) {
                errors.push(`fieldDescriptionMesg fitBaseTypeId is ${fieldDescriptionMesg.fitBaseTypeId}`);
            }
            if (fieldDescriptionMesg.fieldDefinitionNumber == null) {
                errors.push(`fieldDescriptionMesg fieldDefinitionNumber is ${fieldDescriptionMesg.fieldDefinitionNumber}`);
            }
            if (fieldDescriptionMesg.developerDataIndex == null) {
                errors.push(`fieldDescriptionMesg developerDataIndex is ${fieldDescriptionMesg.developerDataIndex}`);
            }
            if (developerDataIdMesg.developerDataIndex == null) {
                errors.push(`developerDataIdMesg developerDataIndex is ${developerDataIdMesg.developerDataIndex}`);
            }

            if (developerDataIdMesg.developerDataIndex !== fieldDescriptionMesg.developerDataIndex) {
                errors.push("developerDataIndex values do not match in fieldDescription"
                    + ` ${developerDataIdMesg.developerDataIndex} != ${fieldDescriptionMesg.developerDataIndex}`
                );
            }

            if (errors.length > 0) {
                throw new Error("missing or invalid values in the fieldDescription,", {
                    cause: {
                        developerDataIdMesg,
                        fieldDescriptionMesg,
                        cause: errors,
                    },
                });
            }

            return { key, developerDataIdMesg, fieldDescriptionMesg, };
        }
        catch (error) {
            throw new Error(
                `invalid field description for key ${key}`, {
                cause: {
                    key,
                    cause: {
                        message: error.message,
                        cause: error.cause,
                    },
                },
            }
            );
        }
    }
}

export default MesgDefinition;
