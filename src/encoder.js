/////////////////////////////////////////////////////////////////////////////////////////////
// Copyright 2025 Garmin International, Inc.
// Licensed under the Flexible and Interoperable Data Transfer (FIT) Protocol License; you
// may not use this file except in compliance with the Flexible and Interoperable Data
// Transfer (FIT) Protocol License.
/////////////////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 21.161.0Release
// Tag = production/release/21.161.0-0-g58854c0
/////////////////////////////////////////////////////////////////////////////////////////////


import CrcCalculator from "./crc-calculator.js";
import FIT from "./fit.js";
import MesgDefinition from "./mesg-definition.js";
import OutputStream from "./output-stream.js";
import Profile from "./profile.js";
import Utils from "./utils.js";

const HEADER_WITH_CRC_SIZE = 14;
const HEADER_WITHOUT_CRC_SIZE = 12;

/**
 * A class for encoding FIT files.
 * @class
 */
class Encoder {
    /**
     Creates a FIT File Encoder
     * @param {Object} [options] - Encoder options (optional)
     * @param {Object.<number,{object, object }} [options.fieldDescriptions=null] - (optional, default null) fieldDescriptions
     * @constructor
     */
    constructor({ fieldDescriptions = null, } = {}) {
        this.#fieldDescriptions = {};

        for (const [key, {developerDataIdMesg, fieldDescriptionMesg}] of Object.entries(fieldDescriptions ?? {})) {
            this.addDeveloperField(key, developerDataIdMesg, fieldDescriptionMesg);
        }

        this.#writeEmptyFileHeader();
    }

    /**
     * Closes the encoder and returns the file data
     * @returns {Uint8Array} A Uint8Array containing the file data
     */
    close() {
        this.#updateFileHeader();
        this.#writeFileCrc();

        return this.#outputStream.uint8Array;
    }

    /**
     * Encodes a mesg into the file.
     * @param {Object} mesg - The message data
     * @param {Number} mesg.mesgNum - The mesg number for this message
     * @return {this}
     */
    writeMesg(mesg) {
        return this.onMesg(mesg.mesgNum, mesg);
    }

    /**
     * Encodes a mesg into the file.
     * This method can be used as a Decoder~mesgListener callback.
     * @param {Number} mesgNum - The message number for this message
     * @param {Object} mesg - The message data
     * @return {this}
     */
    onMesg(mesgNum, mesg) {
        try {
            const mesgDefinition = this.#createMesgDefinition(mesgNum, mesg);
            this.#writeMesgDefinitionIfNotActive(mesgDefinition);

            // Write Message Header
            this.#outputStream.writeUInt8(mesgDefinition.localMesgNum);

            // Write Field Values
            mesgDefinition.fieldDefinitions.forEach((fieldDefinition) => {
                const values = this.#transformValues(mesg[fieldDefinition.name], fieldDefinition);
                const baseTypeDef = FIT.BaseTypeDefinitions[fieldDefinition.baseType];

                this.#outputStream.write(values, baseTypeDef.type);
            });

            // Write Developer Field Values
            mesgDefinition.developerFieldDefinitions.forEach((developerFieldDefinition) => {
                const values = this.#transformValues(
                    mesg.developerFields[developerFieldDefinition.key],
                    developerFieldDefinition);

                const baseTypeDef = FIT.BaseTypeDefinitions[developerFieldDefinition.baseType];

                this.#outputStream.write(values, baseTypeDef.type);
            });
        }
        catch (error) {
            throw new Error(
                "Could not write Message", {
                cause: {
                    mesg,
                    cause: {
                        message: error.message,
                        cause: error.cause,
                    },
                },
            }
            );
        }

        return this;
    };

    /**
     * Adds a Developer Data Field Description and associated Developer Data Id Message to the Endoder
     * This provides the Encoder with the context required to write Developer Fields to the output-stream.
     * *** This method does not write the messages to the output-stream ***
     * This method can be used as a Decoder~fieldDescriptionListener callback.
     * @param {Number} key - The message number for this message
     * @param {Object} developerDataIdMesg - The Developer Data Id mesg
     * @param {Object} fieldDescriptionMesg - The Field Description mesg
     * @return {this}
     */
    addDeveloperField(key, developerDataIdMesg, fieldDescriptionMesg) {
        if(developerDataIdMesg.developerDataIndex == null || fieldDescriptionMesg.developerDataIndex == null) {
            throw new Error("addDeveloperField() - one or more developerDataIndex values are null.", {
                 cause: {
                    key,
                    developerDataIdMesg, 
                    fieldDescriptionMesg
                }
            });
        }

        if(developerDataIdMesg.developerDataIndex !== fieldDescriptionMesg.developerDataIndex) {
            throw new Error("addDeveloperField() - developerDataIndex values do not match.", {
                 cause: {
                    key,
                    developerDataIdMesg, 
                    fieldDescriptionMesg
                }
            });
        }

        this.#fieldDescriptions[key] = {
            developerDataIdMesg,
            fieldDescriptionMesg
        }

        return this;
    }

    #writeEmptyFileHeader() {
        Array(HEADER_WITH_CRC_SIZE).fill(0).forEach((zero) => {
            this.#outputStream.writeUInt8(zero);
        });
    }

    #updateFileHeader() {
        const arrayBuffer = new ArrayBuffer(HEADER_WITH_CRC_SIZE);
        const dataView = new DataView(arrayBuffer);

        // Header Size
        dataView.setUint8(0, HEADER_WITH_CRC_SIZE);

        // Protocol Version
        dataView.setUint8(1, 2);

        // Profile Version
        dataView.setUint16(2, Profile.version.major * 1000 + Profile.version.minor, true);

        // Data Size
        dataView.setUint32(4, this.#outputStream.length - HEADER_WITH_CRC_SIZE, true);

        // Data Type ".FIT"
        dataView.setUint8(8, 0x2E);
        dataView.setUint8(9, 0x46);
        dataView.setUint8(10, 0x49);
        dataView.setUint8(11, 0x54);

        // Header CRC
        const crc = CrcCalculator.calculateCRC(new Uint8Array(arrayBuffer), 0, HEADER_WITHOUT_CRC_SIZE);
        dataView.setUint16(12, crc, true);

        this.#outputStream.set(new Uint8Array(arrayBuffer));
    }

    #writeFileCrc() {
        const crc = CrcCalculator.calculateCRC(this.#outputStream.uint8Array, 0, this.#outputStream.length);
        this.#outputStream.writeUInt16(crc);
    }

    #transformValues(value, fieldDefinition) {
        const values = Array.isArray(value) ? value : [value,];

        return values.map((value) => {
            return this.#transformValue(value, fieldDefinition);
        });
    }

    #transformValue(value, fieldDefinition) {
        try {
            if (FIT.isNotNumberStringDateOrBoolean(value)) {
                return FIT.BaseTypeDefinitions[fieldDefinition.baseType].invalid;
            }

            // Is this a numeric field?
            if (FIT.NumericFieldTypes.includes(fieldDefinition.type)) {
                if (!FIT.isNumeric(value)) {
                    throw new Error();
                }

                const scale = Array.isArray(fieldDefinition.scale) ? fieldDefinition.scale[0] : fieldDefinition.scale;
                const offset = Array.isArray(fieldDefinition.offset) ? fieldDefinition.offset[0] : fieldDefinition.offset;

                return (value + offset) * scale;
            }

            // Is this a date_time field?
            if (fieldDefinition.type === "dateTime") {
                if (FIT.isDate(value)) {
                    return Utils.convertDateToDateTime(value);
                }

                if (!FIT.isNumeric(value)) {
                    throw new Error();
                }

                return value;
            }

            // Is this a string field
            if (fieldDefinition.type === "string") {
                if (!FIT.isString(value)) {
                    throw new Error();
                }

                return value;
            }

            // Must be a FIT type field
            if (FIT.isNumeric(value)) {
                return value;
            }

            const profileType = Profile.types[fieldDefinition.type];

            const [typeValue,] = Object.entries(profileType).find(([, typeValue,]) => {
                return typeValue === value;
            });

            return typeValue;
        }
        catch {
            throw new Error(
                `Could not convert "${value}" to "${fieldDefinition.type}"`,
                { cause: { value, fieldDefinition, }, });
        }
    }

    /**
     * Creates a MesgDefinition from the mesgNum and mesg.
     * @param {Number} mesgNum - The mesg number for this message
     * @param {Object} [mesg] - The message data
     * @return {MesgDefinition}
     */
    #createMesgDefinition = (mesgNum, mesg) => {
        const mesgDefinition = new MesgDefinition(mesgNum, mesg, { fieldDescriptions: this.#fieldDescriptions, });
        mesgDefinition.localMesgNum = this.#lookupLocalMesgNum(mesgDefinition);

        return mesgDefinition;
    };

    /**
     * Searches the #localMesgDefinitions for a matching mesgDefinition
     * @param {Object} mesgDefinition - the mesg definition to match
     * @return The localMesgNum to be used with mesgDefinition
     */
    #lookupLocalMesgNum = (mesgDefinition) => {
        const localMesgNum = this.#localMesgDefinitions.findIndex((localMesgDefinition) => {
            return localMesgDefinition?.equals(mesgDefinition) ?? false;
        });

        return (localMesgNum !== -1 ? localMesgNum : this.#nextLocalMesgNum++) & FIT.LOCAL_MESG_NUM_MASK;
    };

    /**
     * Writes the mesgDefinition to the output stream, if it is not one of the currently active 16
     * @param {Object} mesgDefinition - the mesg definition to match
     * @return The localMesgNum to be used with mesgDefinition
     */
    #writeMesgDefinitionIfNotActive = (mesgDefinition) => {
        const localMesgNum = mesgDefinition.localMesgNum;

        if (this.#localMesgDefinitions[localMesgNum] == null
            || !this.#localMesgDefinitions[localMesgNum].equals(mesgDefinition)) {
            this.#writeMesgDefinition(mesgDefinition);
        }

        return localMesgNum;
    };

    /**
     * Writes the mesgDefinition to the output stream
     * @param {Object} mesgDefinition - the mesg definition to write
     * @return {this}
     */
    #writeMesgDefinition(mesgDefinition) {
        mesgDefinition.write(this.#outputStream);
        this.#localMesgDefinitions[mesgDefinition.localMesgNum] = mesgDefinition;

        return this;
    }

    #localMesgDefinitions = Array(16).fill(null);
    #nextLocalMesgNum = 0;
    #outputStream = new OutputStream();
    #fieldDescriptions = null;
}

export default Encoder;
